<!DOCTYPE html>
<html lang="en-GB">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sound Mixer â€” Ambient sounds for sleep &amp; focus</title>
<meta name="description" content="Mix ambient sounds for sleep and focus. Rain, ocean, fireplace, white noise â€” blend your perfect soundscape. Free, no downloads, runs in your browser.">
<link rel="canonical" href="https://molty-assistant.github.io/sound-mixer-web/">

<!-- Open Graph -->
<meta property="og:title" content="Sound Mixer â€” Ambient sounds for sleep & focus">
<meta property="og:description" content="Mix 12 ambient sounds for sleep and focus. Rain, ocean, fireplace, white noise â€” blend your perfect soundscape. Free, runs in your browser.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://molty-assistant.github.io/sound-mixer-web/">
<meta property="og:locale" content="en_GB">
<meta property="og:site_name" content="Micro Apps">

<!-- Twitter/X Card -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sound Mixer â€” Ambient sounds for sleep & focus">
<meta name="twitter:description" content="Mix 12 ambient sounds for sleep and focus. Free, no downloads, runs in your browser.">

<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸµ</text></svg>">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESET & BASE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:        #0a0a0f;
  --bg-card:   #13131a;
  --bg-card-active: #1a1a28;
  --border:    #1e1e2e;
  --border-active: #7c3aed;
  --text:      #e4e4e7;
  --text-dim:  #71717a;
  --accent:    #7c3aed;
  --accent-glow: rgba(124, 58, 237, 0.3);
  --accent-soft: rgba(124, 58, 237, 0.15);
  --radius:    16px;
  --radius-sm: 10px;
  --font:      -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
}

html {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  min-height: 100vh;
  padding: 0 20px 40px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   HEADER
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.header {
  text-align: center;
  padding: 40px 0 32px;
}

.header h1 {
  font-size: 28px;
  font-weight: 700;
  letter-spacing: -0.5px;
  margin-bottom: 6px;
}

.header p {
  color: var(--text-dim);
  font-size: 15px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONTROLS BAR (master volume + timer)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.controls-bar {
  max-width: 900px;
  margin: 0 auto 28px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  justify-content: center;
}

.control-group {
  display: flex;
  align-items: center;
  gap: 10px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 10px 16px;
  font-size: 14px;
}

.control-group label {
  color: var(--text-dim);
  font-size: 13px;
  white-space: nowrap;
}

.master-slider {
  width: 120px;
}

.timer-select {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 10px;
  font-size: 13px;
  font-family: var(--font);
  cursor: pointer;
  outline: none;
}

.timer-select:focus {
  border-color: var(--accent);
}

.timer-display {
  color: var(--accent);
  font-variant-numeric: tabular-nums;
  font-size: 13px;
  font-weight: 600;
  min-width: 48px;
  text-align: center;
}

.timer-display.hidden { display: none; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PRESETS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.presets {
  max-width: 900px;
  margin: 0 auto 28px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}

.preset-btn {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 40px;
  color: var(--text);
  font-size: 13px;
  font-family: var(--font);
  padding: 8px 18px;
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.preset-btn:hover {
  border-color: var(--accent);
  background: var(--accent-soft);
}

.preset-btn:active {
  transform: scale(0.97);
}

.save-btn {
  background: var(--accent-soft);
  border-color: var(--accent);
  color: var(--accent);
}

.save-btn:hover {
  background: var(--accent);
  color: white;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOUND GRID
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.sound-grid {
  max-width: 900px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 14px;
}

.sound-tile {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 20px 16px 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.25s ease;
  user-select: none;
  -webkit-user-select: none;
  position: relative;
  overflow: hidden;
}

.sound-tile::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: var(--radius);
  opacity: 0;
  background: radial-gradient(circle at 50% 30%, var(--accent-glow), transparent 70%);
  transition: opacity 0.4s ease;
  pointer-events: none;
}

.sound-tile.active {
  border-color: var(--border-active);
  background: var(--bg-card-active);
}

.sound-tile.active::before {
  opacity: 1;
}

.sound-tile .tile-name {
  opacity: 0.5;
  transition: opacity 0.25s ease;
}

.sound-tile.active .tile-name {
  opacity: 1;
}

.sound-tile:hover {
  border-color: #2a2a3e;
}

.sound-tile.active:hover {
  border-color: var(--border-active);
}

.tile-emoji {
  font-size: 36px;
  line-height: 1;
  position: relative;
  z-index: 1;
  transition: transform 0.25s ease, filter 0.25s ease;
  filter: grayscale(0.6) opacity(0.5);
}

.sound-tile.active .tile-emoji {
  transform: scale(1.1);
  filter: grayscale(0) opacity(1);
}

.tile-name {
  font-size: 14px;
  font-weight: 600;
  position: relative;
  z-index: 1;
}

.tile-slider-row {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 8px;
  position: relative;
  z-index: 1;
}

.tile-slider {
  flex: 1;
  height: 4px;
}

.tile-vol {
  font-size: 11px;
  color: var(--text-dim);
  font-variant-numeric: tabular-nums;
  min-width: 28px;
  text-align: right;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RANGE SLIDER STYLING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  cursor: pointer;
  height: 20px;
}

input[type="range"]::-webkit-slider-runnable-track {
  height: 4px;
  border-radius: 2px;
  background: var(--border);
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--text);
  border: none;
  margin-top: -6px;
  transition: background 0.2s, transform 0.15s;
}

input[type="range"]::-webkit-slider-thumb:hover {
  background: var(--accent);
  transform: scale(1.15);
}

input[type="range"]::-moz-range-track {
  height: 4px;
  border-radius: 2px;
  background: var(--border);
  border: none;
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--text);
  border: none;
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb:hover {
  background: var(--accent);
}

/* Active tile slider accent */
.sound-tile.active input[type="range"]::-webkit-slider-thumb {
  background: var(--accent);
}
.sound-tile.active input[type="range"]::-moz-range-thumb {
  background: var(--accent);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FOOTER
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.footer {
  text-align: center;
  margin-top: 48px;
  color: var(--text-dim);
  font-size: 12px;
}

.footer a {
  color: var(--accent);
  text-decoration: none;
}

.footer a:hover { text-decoration: underline; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RESPONSIVE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@media (max-width: 600px) {
  body { padding: 0 12px 32px; }
  .header { padding: 28px 0 20px; }
  .header h1 { font-size: 22px; }
  .sound-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }
  .sound-tile { padding: 16px 12px 12px; }
  .tile-emoji { font-size: 30px; }
  .tile-name { font-size: 13px; }
  .controls-bar { gap: 8px; }
  .control-group { padding: 8px 12px; }
  .master-slider { width: 90px; }
}

@media (max-width: 380px) {
  .sound-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOAST NOTIFICATION
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.toast {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%) translateY(100px);
  background: var(--bg-card);
  border: 1px solid var(--accent);
  color: var(--text);
  padding: 10px 20px;
  border-radius: 40px;
  font-size: 13px;
  font-family: var(--font);
  z-index: 1000;
  opacity: 0;
  transition: all 0.3s ease;
  pointer-events: none;
}

.toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
</style>
</head>
<body>

<div class="header">
  <h1>ğŸµ Sound Mixer</h1>
  <p>Blend ambient sounds for sleep &amp; focus</p>
  <p style="font-size:0.85rem;color:#6b7280;margin-top:0.25rem">Tap any sound to start playing â–¶</p>
</div>

<div class="controls-bar">
  <div class="control-group">
    <label>ğŸ”Š Master</label>
    <input type="range" class="master-slider" id="masterVolume" min="0" max="100" value="80">
  </div>
  <div class="control-group">
    <label>â± Timer</label>
    <select class="timer-select" id="timerSelect">
      <option value="0">Off</option>
      <option value="15">15 min</option>
      <option value="30">30 min</option>
      <option value="60">1 hour</option>
      <option value="120">2 hours</option>
    </select>
    <span class="timer-display hidden" id="timerDisplay">00:00</span>
  </div>
</div>

<div class="presets" id="presets">
  <button class="preset-btn" data-preset="rainy-night">ğŸŒ§ Rainy Night</button>
  <button class="preset-btn" data-preset="ocean-breeze">ğŸŒŠ Ocean Breeze</button>
  <button class="preset-btn" data-preset="deep-focus">ğŸ§  Deep Focus</button>
  <button class="preset-btn" data-preset="forest-stream">ğŸŒ² Forest Stream</button>
  <button class="preset-btn save-btn" id="saveMix">ğŸ’¾ Save Mix</button>
  <button class="preset-btn" id="loadMix">ğŸ“‚ Load Mix</button>
</div>

<div class="sound-grid" id="soundGrid"></div>

<div class="toast" id="toast"></div>

<div class="footer">
  <p>Sound Mixer â€” Part of <a href="https://molty-assistant.github.io/micro-apps-site/">Micro Apps</a></p>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONFIGURATION
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const SOUNDS = [
  { id: 'rain',        name: 'Rain',        emoji: 'ğŸŒ§ï¸' },
  { id: 'thunder',     name: 'Thunder',     emoji: 'â›ˆï¸' },
  { id: 'ocean',       name: 'Ocean',       emoji: 'ğŸŒŠ' },
  { id: 'forest',      name: 'Forest',      emoji: 'ğŸŒ²' },
  { id: 'wind',        name: 'Wind',        emoji: 'ğŸ’¨' },
  { id: 'fireplace',   name: 'Fireplace',   emoji: 'ğŸ”¥' },
  { id: 'birds',       name: 'Birds',       emoji: 'ğŸ¦' },
  { id: 'creek',       name: 'Creek',       emoji: 'ğŸï¸' },
  { id: 'whitenoise',  name: 'White Noise', emoji: 'âšª' },
  { id: 'pinknoise',   name: 'Pink Noise',  emoji: 'ğŸ©·' },
  { id: 'brownnoise',  name: 'Brown Noise', emoji: 'ğŸŸ¤' },
  { id: 'fan',         name: 'Fan',         emoji: 'ğŸŒ€' },
];

const PRESETS = {
  'rainy-night':   { rain: 70, thunder: 50, fireplace: 70 },
  'ocean-breeze':  { ocean: 70, wind: 50, birds: 60 },
  'deep-focus':    { brownnoise: 70, rain: 50 },
  'forest-stream': { forest: 70, creek: 65, birds: 55 },
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AUDIO ENGINE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let audioCtx = null;
let masterGain = null;
const soundNodes = {};  // id -> { gain, sources[], active, volume, cleanup }

function ensureAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.8;
    masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

/* --- Noise buffer generators --- */
function createNoiseBuffer(type) {
  const sr = audioCtx.sampleRate;
  const len = sr * 4; // 4 second loop
  const buffer = audioCtx.createBuffer(1, len, sr);
  const data = buffer.getChannelData(0);

  if (type === 'white') {
    for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
  } else if (type === 'pink') {
    let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
    for (let i = 0; i < len; i++) {
      const w = Math.random() * 2 - 1;
      b0 = 0.99886 * b0 + w * 0.0555179;
      b1 = 0.99332 * b1 + w * 0.0750759;
      b2 = 0.96900 * b2 + w * 0.1538520;
      b3 = 0.86650 * b3 + w * 0.3104856;
      b4 = 0.55000 * b4 + w * 0.5329522;
      b5 = -0.7616 * b5 - w * 0.0168980;
      data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + w * 0.5362) * 0.11;
      b6 = w * 0.115926;
    }
  } else if (type === 'brown') {
    let last = 0;
    for (let i = 0; i < len; i++) {
      const w = Math.random() * 2 - 1;
      last = (last + (0.02 * w)) / 1.02;
      data[i] = last * 3.5;
    }
  }
  return buffer;
}

function makeNoiseSource(buffer) {
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  src.loop = true;
  return src;
}

/* --- Sound synthesizers --- */
function createSoundGraph(id, gainNode) {
  const sources = [];
  const cleanups = [];

  function noiseSource(type) {
    const buf = createNoiseBuffer(type);
    const src = makeNoiseSource(buf);
    sources.push(src);
    return src;
  }

  switch (id) {
    case 'whitenoise': {
      const src = noiseSource('white');
      src.connect(gainNode);
      break;
    }
    case 'pinknoise': {
      const src = noiseSource('pink');
      src.connect(gainNode);
      break;
    }
    case 'brownnoise': {
      const src = noiseSource('brown');
      src.connect(gainNode);
      break;
    }
    case 'rain': {
      // Base: filtered noise
      const src = noiseSource('white');
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 1800;
      bp.Q.value = 0.5;
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 400;
      src.connect(bp).connect(hp).connect(gainNode);

      // Droplet bursts
      const dropletInterval = setInterval(() => {
        if (audioCtx.state !== 'running') return;
        const numDrops = Math.floor(Math.random() * 4) + 1;
        for (let d = 0; d < numDrops; d++) {
          setTimeout(() => {
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            const f = 2000 + Math.random() * 4000;
            osc.frequency.setValueAtTime(f, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(f * 0.3, audioCtx.currentTime + 0.04);
            g.gain.setValueAtTime(0.03, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.04);
            osc.connect(g).connect(gainNode);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.05);
          }, Math.random() * 200);
        }
      }, 150);
      cleanups.push(() => clearInterval(dropletInterval));
      break;
    }
    case 'thunder': {
      // Low rumble
      const src = noiseSource('brown');
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 150;
      const rumbleGain = audioCtx.createGain();
      rumbleGain.gain.value = 1.5;
      src.connect(lp).connect(rumbleGain).connect(gainNode);

      // Mid rumble layer
      const src2 = noiseSource('brown');
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 80;
      bp.Q.value = 0.5;
      const midGain = audioCtx.createGain();
      midGain.gain.value = 0.5;
      src2.connect(bp).connect(midGain).connect(gainNode);

      // Occasional booms
      const boomInterval = setInterval(() => {
        if (audioCtx.state !== 'running') return;
        if (Math.random() > 0.3) return; // ~30% chance each 3s
        const t = audioCtx.currentTime;
        const boomBuf = createNoiseBuffer('brown');
        const boomSrc = audioCtx.createBufferSource();
        boomSrc.buffer = boomBuf;
        const boomLp = audioCtx.createBiquadFilter();
        boomLp.type = 'lowpass';
        boomLp.frequency.value = 100;
        const boomGain = audioCtx.createGain();
        boomGain.gain.setValueAtTime(0.001, t);
        boomGain.gain.exponentialRampToValueAtTime(2.0, t + 0.1);
        boomGain.gain.exponentialRampToValueAtTime(0.3, t + 0.5);
        boomGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5);
        boomSrc.connect(boomLp).connect(boomGain).connect(gainNode);
        boomSrc.start(t);
        boomSrc.stop(t + 3);
      }, 3000);
      cleanups.push(() => clearInterval(boomInterval));
      break;
    }
    case 'ocean': {
      // Noise base with wave modulation
      const src = noiseSource('pink');
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 500;
      bp.Q.value = 0.3;
      const waveGain = audioCtx.createGain();
      waveGain.gain.value = 0.5;

      // LFO for wave motion
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.08; // slow waves ~8s cycle
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.5;
      lfo.connect(lfoGain).connect(waveGain.gain);
      lfo.start();
      sources.push(lfo);

      src.connect(bp).connect(waveGain).connect(gainNode);

      // Second wave layer (slightly offset)
      const src2 = noiseSource('brown');
      const lp2 = audioCtx.createBiquadFilter();
      lp2.type = 'lowpass';
      lp2.frequency.value = 300;
      const waveGain2 = audioCtx.createGain();
      waveGain2.gain.value = 0.3;
      const lfo2 = audioCtx.createOscillator();
      lfo2.type = 'sine';
      lfo2.frequency.value = 0.06;
      const lfoGain2 = audioCtx.createGain();
      lfoGain2.gain.value = 0.3;
      lfo2.connect(lfoGain2).connect(waveGain2.gain);
      lfo2.start();
      sources.push(lfo2);
      src2.connect(lp2).connect(waveGain2).connect(gainNode);

      // Occasional wave crash
      const crashInterval = setInterval(() => {
        if (audioCtx.state !== 'running') return;
        if (Math.random() > 0.4) return;
        const t = audioCtx.currentTime;
        const cBuf = createNoiseBuffer('white');
        const cSrc = audioCtx.createBufferSource();
        cSrc.buffer = cBuf;
        const cBp = audioCtx.createBiquadFilter();
        cBp.type = 'bandpass';
        cBp.frequency.value = 800;
        cBp.Q.value = 0.3;
        const cGain = audioCtx.createGain();
        cGain.gain.setValueAtTime(0.001, t);
        cGain.gain.exponentialRampToValueAtTime(0.15, t + 0.5);
        cGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5);
        cSrc.connect(cBp).connect(cGain).connect(gainNode);
        cSrc.start(t);
        cSrc.stop(t + 3);
      }, 4000);
      cleanups.push(() => clearInterval(crashInterval));
      break;
    }
    case 'forest': {
      // Gentle filtered noise
      const src = noiseSource('pink');
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 800;
      bp.Q.value = 0.2;
      const envGain = audioCtx.createGain();
      envGain.gain.value = 0.6;

      // Subtle slow modulation
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.15;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.2;
      lfo.connect(lfoGain).connect(envGain.gain);
      lfo.start();
      sources.push(lfo);

      src.connect(bp).connect(envGain).connect(gainNode);

      // Low rustle layer
      const src2 = noiseSource('brown');
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 200;
      const rustleGain = audioCtx.createGain();
      rustleGain.gain.value = 0.15;
      src2.connect(lp).connect(rustleGain).connect(gainNode);
      break;
    }
    case 'wind': {
      // Noise with slow amplitude wandering
      const src = noiseSource('pink');
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 600;
      bp.Q.value = 0.3;
      const windGain = audioCtx.createGain();
      windGain.gain.value = 0.5;

      // Very slow wandering LFO
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.05;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.45;
      lfo.connect(lfoGain).connect(windGain.gain);
      lfo.start();
      sources.push(lfo);

      src.connect(bp).connect(windGain).connect(gainNode);

      // Higher whistle layer
      const src2 = noiseSource('white');
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 3000;
      const whistleGain = audioCtx.createGain();
      whistleGain.gain.value = 0.04;
      const lfo2 = audioCtx.createOscillator();
      lfo2.type = 'sine';
      lfo2.frequency.value = 0.03;
      const lfoGain2 = audioCtx.createGain();
      lfoGain2.gain.value = 0.03;
      lfo2.connect(lfoGain2).connect(whistleGain.gain);
      lfo2.start();
      sources.push(lfo2);
      src2.connect(hp).connect(whistleGain).connect(gainNode);
      break;
    }
    case 'fireplace': {
      // Base crackle
      const src = noiseSource('brown');
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 600;
      bp.Q.value = 0.8;
      const baseGain = audioCtx.createGain();
      baseGain.gain.value = 0.4;
      src.connect(bp).connect(baseGain).connect(gainNode);

      // Low warmth
      const src2 = noiseSource('brown');
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 180;
      const warmGain = audioCtx.createGain();
      warmGain.gain.value = 0.3;
      src2.connect(lp).connect(warmGain).connect(gainNode);

      // Random crackling transients
      const crackleInterval = setInterval(() => {
        if (audioCtx.state !== 'running') return;
        const numCracks = Math.floor(Math.random() * 5) + 1;
        for (let c = 0; c < numCracks; c++) {
          setTimeout(() => {
            const t = audioCtx.currentTime;
            const cBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.03, audioCtx.sampleRate);
            const cData = cBuf.getChannelData(0);
            for (let i = 0; i < cData.length; i++) {
              cData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / cData.length, 3);
            }
            const cSrc = audioCtx.createBufferSource();
            cSrc.buffer = cBuf;
            const cBp = audioCtx.createBiquadFilter();
            cBp.type = 'bandpass';
            cBp.frequency.value = 1500 + Math.random() * 3000;
            cBp.Q.value = 2;
            const cGain = audioCtx.createGain();
            cGain.gain.setValueAtTime(0.15 + Math.random() * 0.2, t);
            cGain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
            cSrc.connect(cBp).connect(cGain).connect(gainNode);
            cSrc.start(t);
            cSrc.stop(t + 0.05);
          }, Math.random() * 400);
        }
      }, 120);
      cleanups.push(() => clearInterval(crackleInterval));
      break;
    }
    case 'birds': {
      // Background gentle noise
      const src = noiseSource('pink');
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 2000;
      const bgGain = audioCtx.createGain();
      bgGain.gain.value = 0.06;
      src.connect(hp).connect(bgGain).connect(gainNode);

      // Synthetic chirps
      const chirpInterval = setInterval(() => {
        if (audioCtx.state !== 'running') return;
        if (Math.random() > 0.6) return;
        const numChirps = Math.floor(Math.random() * 3) + 1;
        for (let ch = 0; ch < numChirps; ch++) {
          setTimeout(() => {
            const t = audioCtx.currentTime;
            const baseFreq = 2000 + Math.random() * 3000;
            // Each chirp is 2-4 notes
            const noteCount = Math.floor(Math.random() * 3) + 2;
            for (let n = 0; n < noteCount; n++) {
              const noteTime = t + n * (0.06 + Math.random() * 0.08);
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              const freq = baseFreq * (0.8 + Math.random() * 0.5);
              osc.frequency.setValueAtTime(freq, noteTime);
              osc.frequency.exponentialRampToValueAtTime(freq * (0.7 + Math.random() * 0.6), noteTime + 0.05);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.001, noteTime);
              g.gain.exponentialRampToValueAtTime(0.06 + Math.random() * 0.04, noteTime + 0.01);
              g.gain.exponentialRampToValueAtTime(0.001, noteTime + 0.05 + Math.random() * 0.03);
              osc.connect(g).connect(gainNode);
              osc.start(noteTime);
              osc.stop(noteTime + 0.1);
            }
          }, Math.random() * 600);
        }
      }, 800);
      cleanups.push(() => clearInterval(chirpInterval));
      break;
    }
    case 'creek': {
      // High-pass filtered noise base
      const src = noiseSource('white');
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 2500;
      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = 3500;
      bp.Q.value = 0.3;
      const creekGain = audioCtx.createGain();
      creekGain.gain.value = 0.25;

      // Babbling modulation
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 2.5;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.15;
      lfo.connect(lfoGain).connect(creekGain.gain);
      lfo.start();
      sources.push(lfo);

      src.connect(hp).connect(bp).connect(creekGain).connect(gainNode);

      // Secondary babble layer
      const src2 = noiseSource('pink');
      const bp2 = audioCtx.createBiquadFilter();
      bp2.type = 'bandpass';
      bp2.frequency.value = 1800;
      bp2.Q.value = 0.5;
      const babbleGain = audioCtx.createGain();
      babbleGain.gain.value = 0.15;
      const lfo2 = audioCtx.createOscillator();
      lfo2.type = 'sine';
      lfo2.frequency.value = 3.8;
      const lfoGain2 = audioCtx.createGain();
      lfoGain2.gain.value = 0.1;
      lfo2.connect(lfoGain2).connect(babbleGain.gain);
      lfo2.start();
      sources.push(lfo2);
      src2.connect(bp2).connect(babbleGain).connect(gainNode);

      // Occasional splash
      const splashInterval = setInterval(() => {
        if (audioCtx.state !== 'running') return;
        if (Math.random() > 0.35) return;
        const t = audioCtx.currentTime;
        const sBuf = createNoiseBuffer('white');
        const sSrc = audioCtx.createBufferSource();
        sSrc.buffer = sBuf;
        const sHp = audioCtx.createBiquadFilter();
        sHp.type = 'highpass';
        sHp.frequency.value = 3000;
        const sGain = audioCtx.createGain();
        sGain.gain.setValueAtTime(0.001, t);
        sGain.gain.exponentialRampToValueAtTime(0.08, t + 0.02);
        sGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        sSrc.connect(sHp).connect(sGain).connect(gainNode);
        sSrc.start(t);
        sSrc.stop(t + 0.2);
      }, 600);
      cleanups.push(() => clearInterval(splashInterval));
      break;
    }
    case 'fan': {
      // Steady noise blend
      const src = noiseSource('pink');
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 1200;
      const fanGain = audioCtx.createGain();
      fanGain.gain.value = 0.6;
      src.connect(lp).connect(fanGain).connect(gainNode);

      // Brown noise layer for depth
      const src2 = noiseSource('brown');
      const lp2 = audioCtx.createBiquadFilter();
      lp2.type = 'lowpass';
      lp2.frequency.value = 400;
      const depthGain = audioCtx.createGain();
      depthGain.gain.value = 0.25;
      src2.connect(lp2).connect(depthGain).connect(gainNode);

      // Very subtle rotation modulation
      const lfo = audioCtx.createOscillator();
      lfo.type = 'sine';
      lfo.frequency.value = 0.8;
      const lfoGain = audioCtx.createGain();
      lfoGain.gain.value = 0.04;
      lfo.connect(lfoGain).connect(fanGain.gain);
      lfo.start();
      sources.push(lfo);
      break;
    }
  }

  return { sources, cleanups };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOUND STATE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function startSound(id) {
  ensureAudioCtx();
  if (soundNodes[id] && soundNodes[id].active) return;

  const gain = audioCtx.createGain();
  const vol = soundNodes[id] ? soundNodes[id].volume : 70;
  gain.gain.setValueAtTime(vol / 100, audioCtx.currentTime);
  gain.connect(masterGain);

  const { sources, cleanups } = createSoundGraph(id, gain);
  sources.forEach(s => { try { s.start(); } catch(e) {} });

  soundNodes[id] = {
    gain,
    sources,
    cleanups,
    active: true,
    volume: vol,
  };

  updateTileUI(id, true);
}

function stopSound(id) {
  const node = soundNodes[id];
  if (!node || !node.active) return;

  // Smooth fade out to prevent click
  const t = audioCtx.currentTime;
  node.gain.gain.setValueAtTime(node.gain.gain.value, t);
  node.gain.gain.linearRampToValueAtTime(0, t + 0.05);

  setTimeout(() => {
    node.sources.forEach(s => { try { s.stop(); } catch(e) {} });
    node.cleanups.forEach(fn => fn());
    try { node.gain.disconnect(); } catch(e) {}
  }, 80);

  soundNodes[id] = { ...node, active: false, sources: [], cleanups: [] };
  updateTileUI(id, false);
}

function toggleSound(id) {
  ensureAudioCtx();
  if (soundNodes[id] && soundNodes[id].active) {
    stopSound(id);
  } else {
    startSound(id);
  }
}

function setVolume(id, vol) {
  if (!soundNodes[id]) {
    soundNodes[id] = { gain: null, sources: [], cleanups: [], active: false, volume: vol };
  }
  soundNodes[id].volume = vol;
  if (soundNodes[id].active && soundNodes[id].gain) {
    // Smooth volume change to prevent pops
    const t = audioCtx.currentTime;
    soundNodes[id].gain.gain.setTargetAtTime(vol / 100, t, 0.02);
  }
}

function stopAll() {
  SOUNDS.forEach(s => stopSound(s.id));
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UI RENDERING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const grid = document.getElementById('soundGrid');

SOUNDS.forEach(sound => {
  const tile = document.createElement('div');
  tile.className = 'sound-tile';
  tile.id = `tile-${sound.id}`;
  tile.innerHTML = `
    <div class="tile-emoji">${sound.emoji}</div>
    <div class="tile-name">${sound.name}</div>
    <div class="tile-slider-row">
      <input type="range" class="tile-slider" min="0" max="100" value="70"
             id="slider-${sound.id}" aria-label="${sound.name} volume">
      <span class="tile-vol" id="vol-${sound.id}">70</span>
    </div>
  `;

  // Toggle on tile click (but not on slider)
  tile.addEventListener('click', (e) => {
    if (e.target.tagName === 'INPUT') return;
    toggleSound(sound.id);
  });

  // Volume slider
  const slider = tile.querySelector(`#slider-${sound.id}`);
  slider.addEventListener('input', (e) => {
    e.stopPropagation();
    const vol = parseInt(e.target.value);
    document.getElementById(`vol-${sound.id}`).textContent = vol;
    setVolume(sound.id, vol);
  });

  // Prevent tile toggle when clicking slider
  slider.addEventListener('click', (e) => e.stopPropagation());

  grid.appendChild(tile);

  // Init state
  soundNodes[sound.id] = { gain: null, sources: [], cleanups: [], active: false, volume: 70 };
});

function updateTileUI(id, active) {
  const tile = document.getElementById(`tile-${id}`);
  if (tile) {
    tile.classList.toggle('active', active);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MASTER VOLUME
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.getElementById('masterVolume').addEventListener('input', (e) => {
  const val = parseInt(e.target.value) / 100;
  if (masterGain) {
    masterGain.gain.setTargetAtTime(val, audioCtx.currentTime, 0.02);
  }
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SLEEP TIMER
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let timerInterval = null;
let timerEndTime = null;
let timerFading = false;

const timerSelect = document.getElementById('timerSelect');
const timerDisplay = document.getElementById('timerDisplay');

timerSelect.addEventListener('change', () => {
  const minutes = parseInt(timerSelect.value);
  clearTimer();

  if (minutes === 0) {
    timerDisplay.classList.add('hidden');
    // Restore master volume if was fading
    if (timerFading && masterGain) {
      const masterSlider = document.getElementById('masterVolume');
      masterGain.gain.setTargetAtTime(parseInt(masterSlider.value) / 100, audioCtx.currentTime, 0.5);
      timerFading = false;
    }
    return;
  }

  timerEndTime = Date.now() + minutes * 60 * 1000;
  timerDisplay.classList.remove('hidden');
  timerFading = false;

  timerInterval = setInterval(() => {
    const remaining = timerEndTime - Date.now();
    if (remaining <= 0) {
      stopAll();
      clearTimer();
      timerDisplay.classList.add('hidden');
      timerSelect.value = '0';
      return;
    }

    // Show countdown
    const mins = Math.floor(remaining / 60000);
    const secs = Math.floor((remaining % 60000) / 1000);
    timerDisplay.textContent = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;

    // Fade out in last 30 seconds
    if (remaining <= 30000 && !timerFading && masterGain) {
      timerFading = true;
      masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 8); // exponential fade
    }
  }, 250);
});

function clearTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
  timerEndTime = null;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PRESETS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
  btn.addEventListener('click', () => {
    const presetId = btn.dataset.preset;
    const preset = PRESETS[presetId];
    if (!preset) return;

    // Stop all sounds first
    stopAll();

    // Activate preset sounds
    Object.entries(preset).forEach(([soundId, vol]) => {
      const slider = document.getElementById(`slider-${soundId}`);
      const volLabel = document.getElementById(`vol-${soundId}`);
      if (slider) {
        slider.value = vol;
        volLabel.textContent = vol;
      }
      setVolume(soundId, vol);
      startSound(soundId);
    });

    showToast(`${btn.textContent.trim()} activated`);
  });
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SAVE / LOAD MIX
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.getElementById('saveMix').addEventListener('click', () => {
  const mix = {};
  SOUNDS.forEach(s => {
    const node = soundNodes[s.id];
    if (node && node.active) {
      mix[s.id] = node.volume;
    }
  });

  if (Object.keys(mix).length === 0) {
    showToast('No sounds active to save');
    return;
  }

  localStorage.setItem('soundmixer-mymix', JSON.stringify(mix));
  showToast('Mix saved âœ“');
});

document.getElementById('loadMix').addEventListener('click', () => {
  const saved = localStorage.getItem('soundmixer-mymix');
  if (!saved) {
    showToast('No saved mix found');
    return;
  }

  const mix = JSON.parse(saved);
  stopAll();

  Object.entries(mix).forEach(([soundId, vol]) => {
    const slider = document.getElementById(`slider-${soundId}`);
    const volLabel = document.getElementById(`vol-${soundId}`);
    if (slider) {
      slider.value = vol;
      volLabel.textContent = vol;
    }
    setVolume(soundId, vol);
    startSound(soundId);
  });

  showToast('Mix loaded âœ“');
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TOAST
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2000);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   iOS AUDIO UNLOCK
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.addEventListener('touchstart', function unlock() {
  ensureAudioCtx();
  document.removeEventListener('touchstart', unlock);
}, { once: true });
</script>
</body>
</html>
